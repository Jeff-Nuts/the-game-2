<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Neon Square - 8-Directional Dash</title>
    <style>
      /* --- RESET & LAYOUT --- */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #050505;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        color: #fff;
        font-family: "Segoe UI", sans-serif;
        user-select: none;
      }

      /* --- MAIN GAME CONTAINER --- */
      #game-container {
        position: relative;
        width: 800px;
        height: 450px;
        background: #000;
        box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
        overflow: hidden;
      }

      /* LAYER 0: CANVAS */
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        width: 100%;
        height: 100%;
        background: #0a0a10;
        cursor: none;
        z-index: 0;
      }

      /* LAYER 1: UI HUD */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      #ui-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 220px;
        height: 100px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 12px;
      }

      .ui-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        font-weight: bold;
      }
      .label {
        color: #fff;
        margin-right: 10px;
        min-width: 70px;
      }

      .hp-container {
        flex-grow: 1;
        height: 12px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      #hp-fill {
        height: 100%;
        width: 100%;
        background-color: #ffff00;
        transition: width 0.1s linear, background-color 0.2s;
      }

      .pips-container {
        display: flex;
        gap: 4px;
      }
      .pip {
        width: 15px;
        height: 10px;
        background-color: #333;
        border-radius: 1px;
        transition: background-color 0.1s;
      }
      .pip.jump-active {
        background-color: #ffff00;
        box-shadow: 0 0 5px #ffff00;
      }
      .pip.dash-active {
        background-color: #00f3ff;
        box-shadow: 0 0 5px #00f3ff;
      }

      /* LAYER 2: CINEMATIC */
      #cinematic-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      #cinematic-layer.active {
        opacity: 1;
      }

      .cine-bar {
        width: 100%;
        height: 0;
        background-color: #000;
        transition: height 0.5s ease;
      }

      #cinematic-layer.active .cine-bar {
        height: 60px;
      }

      #dialogue-box {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #fff;
        padding: 20px;
        text-align: center;
        font-family: "Courier New", monospace;
        display: none;
      }
      #cinematic-layer.active #dialogue-box {
        display: block;
      }

      /* LAYER 3: GLOBAL FADE */
      #fade-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 30;
        opacity: 0;
        pointer-events: none;
        transition: opacity 1s ease;
      }
      #fade-overlay.black {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="game" width="800" height="450"></canvas>

      <div id="ui-layer">
        <div id="ui-panel">
          <div class="ui-row">
            <span class="label">HP</span>
            <div class="hp-container"><div id="hp-fill"></div></div>
          </div>
          <div class="ui-row">
            <span class="label">Wall Jumps</span>
            <div id="jumps-container" class="pips-container"></div>
          </div>
          <div class="ui-row">
            <span class="label">Dashes</span>
            <div id="dashes-container" class="pips-container"></div>
          </div>
        </div>
      </div>

      <div id="cinematic-layer">
        <div class="cine-bar top"></div>
        <div id="dialogue-box">System Initialized...</div>
        <div class="cine-bar bottom"></div>
      </div>

      <div id="fade-overlay"></div>
    </div>

    <script>
      // ================== CONFIGURATION ==================
      class Config {
        static PHYSICS = {
          GRAVITY: 0.6,

          // MOVEMENT
          RUN_SPEED: 4.0, // Normal walking speed
          ACCEL: 1.5, // How fast we get to run speed

          // MOMENTUM
          GROUND_FRICTION: 0.92, // Higher = Slippery, Lower = Sticky (0.92 is good for sliding)
          AIR_RESISTANCE: 0.98, // Preserves momentum in air (Super Dash)

          // WALL
          WALL_SLIDE_SPEED: 2,
          TERMINAL_VELOCITY: 18,

          // DASH
          DASH_SPEED: 18.0, // High burst
          DASH_DURATION: 10, // Slightly longer to feel the weight
          DASH_REGEN_TIME: 30,

          // JUMP
          JUMP_POWER: -13,
          JUMP_CUTOFF: 0.5, // Variable jump height factor
        };

        static WORLD = {
          WIDTH: 2000,
          HEIGHT: 1200,
        };

        static COLORS = {
          PLAYER: "#FFFF00",
          PLAYER_EYES: "#000000",
          ENEMY: "#ff0055",
          ENEMY_EYES: "#330000",
          WALL: "#1e1e24",
          WALL_GLOW: "rgba(0, 0, 0, 0)",
          DASH_ACTIVE: "#00f3ff",
        };
      }

      // ================== UTILITIES ==================
      class Utils {
        static rand(min, max) {
          return Math.random() * (max - min) + min;
        }
        static lerp(start, end, amt) {
          return (1 - amt) * start + amt * end;
        }
        static checkAABB(rect1, rect2) {
          return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
          );
        }
        static getAngle(x1, y1, x2, y2) {
          return Math.atan2(y2 - y1, x2 - x1);
        }
      }

      // ================== INPUT ==================
      class InputHandler {
        constructor(canvas) {
          this.keys = {};
          this.keysPressed = {};
          this.mouse = { x: 0, y: 0, down: false };
          this.canvas = canvas;
          window.addEventListener("keydown", (e) => {
            const k = e.key.toLowerCase();
            if (!this.keys[k]) this.keysPressed[k] = true;
            this.keys[k] = true;
          });
          window.addEventListener("keyup", (e) => {
            const k = e.key.toLowerCase();
            this.keys[k] = false;
            this.keysPressed[k] = false;
          });
          canvas.addEventListener("mousemove", (e) => {
            const r = canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - r.left;
            this.mouse.y = e.clientY - r.top;
          });
          canvas.addEventListener("mousedown", (e) => {
            if (e.button === 0) this.mouse.down = true;
          });
          canvas.addEventListener("mouseup", (e) => {
            if (e.button === 0) this.mouse.down = false;
          });
        }
        isDown(key) {
          return !!this.keys[key];
        }
        isPressed(key) {
          return !!this.keysPressed[key];
        }
        clearFrame() {
          this.keysPressed = {};
        }
      }

      // ================== UI MANAGER ==================
      class UIManager {
        constructor(maxJumps, maxDashes) {
          this.uiLayer = document.getElementById("ui-layer");
          this.cinematicLayer = document.getElementById("cinematic-layer");
          this.fadeOverlay = document.getElementById("fade-overlay");
          this.hpFill = document.getElementById("hp-fill");
          this.jumpsContainer = document.getElementById("jumps-container");
          this.dashesContainer = document.getElementById("dashes-container");

          this.jumpPips = [];
          this.dashPips = [];
          this._createPips(this.jumpsContainer, this.jumpPips, maxJumps);
          this._createPips(this.dashesContainer, this.dashPips, maxDashes);
        }

        _createPips(container, array, count) {
          container.innerHTML = "";
          for (let i = 0; i < count; i++) {
            const pip = document.createElement("div");
            pip.className = "pip";
            container.appendChild(pip);
            array.push(pip);
          }
        }

        update(player) {
          const hpPct = Math.max(0, player.health / player.maxHealth) * 100;
          this.hpFill.style.width = `${hpPct}%`;
          this.hpFill.style.backgroundColor =
            hpPct > 30 ? Config.COLORS.PLAYER : "#ff0000";

          this.jumpPips.forEach((pip, i) => {
            if (i < player.wallJumps) pip.classList.add("jump-active");
            else pip.classList.remove("jump-active");
          });
          this.dashPips.forEach((pip, i) => {
            if (i < player.dashes) pip.classList.add("dash-active");
            else pip.classList.remove("dash-active");
          });
        }

        setCinematicMode(active) {
          if (active) {
            this.uiLayer.style.opacity = "0";
            this.cinematicLayer.classList.add("active");
          } else {
            this.uiLayer.style.opacity = "1";
            this.cinematicLayer.classList.remove("active");
          }
        }
        triggerFade(isBlack) {
          if (isBlack) this.fadeOverlay.classList.add("black");
          else this.fadeOverlay.classList.remove("black");
        }
      }

      // ================== VISUAL FX ==================
      class Particle {
        constructor(x, y, type, color, size = null) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.color = color;
          this.life = 1.0;
          this.size = size;
          this._initPhysics();
        }
        _initPhysics() {
          const angle = Utils.rand(0, Math.PI * 2);
          if (this.type === "dust") {
            this.dx = Math.cos(angle) * 0.5;
            this.dy = -Utils.rand(0.5, 2);
            this.decay = 0.04;
            this.size = this.size || Utils.rand(2, 4);
          } else if (this.type === "spark") {
            const speed = 3;
            this.dx = Math.cos(angle) * speed;
            this.dy = Math.sin(angle) * speed;
            this.decay = 0.06;
            this.size = this.size || Utils.rand(2, 5);
          } else if (this.type === "trail") {
            this.dx = 0;
            this.dy = 0;
            this.decay = 0.1;
            this.size = this.size || Utils.rand(2, 4);
          }
        }
        update() {
          this.x += this.dx;
          this.y += this.dy;
          this.life -= this.decay;
          if (this.type === "spark") {
            this.dy += 0.2;
            this.dx *= 0.95;
          }
        }
        draw(ctx) {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.shadowBlur = this.type === "spark" ? 10 : 0;
          ctx.shadowColor = this.color;
          ctx.fillRect(
            this.x - this.size / 2,
            this.y - this.size / 2,
            this.size,
            this.size
          );
          ctx.globalAlpha = 1.0;
          ctx.shadowBlur = 0;
        }
      }

      class ParticleSystem {
        constructor() {
          this.particles = [];
        }
        update() {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
          }
        }
        draw(ctx) {
          this.particles.forEach((p) => p.draw(ctx));
        }
        emitDust(x, y) {
          for (let i = 0; i < 4; i++)
            this.particles.push(new Particle(x, y, "dust", "#888"));
        }
        emitExplosion(x, y, color) {
          for (let i = 0; i < 12; i++)
            this.particles.push(new Particle(x, y, "spark", color));
        }
        emitTrail(x, y, color, size) {
          if (Math.random() > 0.3)
            this.particles.push(new Particle(x, y, "trail", color, size));
        }
        emitGhost(x, y, width, height, color) {
          const p = new Particle(
            x + width / 2,
            y + height / 2,
            "trail",
            color,
            width
          );
          p.decay = 0.15;
          this.particles.push(p);
        }
      }

      // ================== ENTITIES ==================
      class Entity {
        constructor(x, y, w, h, color) {
          this.x = x;
          this.y = y;
          this.width = w;
          this.height = h;
          this.color = color;
          this.dx = 0;
          this.dy = 0;
          this.onGround = false;
          this.onWall = false;
          this.scaleX = 1;
          this.scaleY = 1;
          this.facing = "right";
        }
        updatePhysics(level, context) {
          this.scaleX = Utils.lerp(this.scaleX, 1, 0.2);
          this.scaleY = Utils.lerp(this.scaleY, 1, 0.2);
          this.dy += Config.PHYSICS.GRAVITY;
          if (this.onWall && this.dy > 0 && !this.onGround)
            this.dy = Config.PHYSICS.WALL_SLIDE_SPEED;
          let nextX = this.x + this.dx;
          let nextY = this.y + this.dy;
          this.onGround = false;
          this.onWall = false;
          for (const plat of level.platforms) {
            if (
              Utils.checkAABB(
                { x: nextX, y: this.y, width: this.width, height: this.height },
                plat
              )
            ) {
              if (this.dx > 0) {
                nextX = plat.x - this.width;
                this.onWall = "right";
              } else if (this.dx < 0) {
                nextX = plat.x + plat.width;
                this.onWall = "left";
              }
              this.dx = 0;
            }
            if (
              Utils.checkAABB(
                { x: nextX, y: nextY, width: this.width, height: this.height },
                plat
              )
            ) {
              if (this.dy > 0) {
                nextY = plat.y - this.height;
                this.onGround = true;
                if (this.dy > 2) {
                  this.scaleX = 1.4;
                  this.scaleY = 0.6;
                  context.particles.emitDust(
                    this.x + this.width / 2,
                    this.y + this.height
                  );
                }
              } else if (this.dy < 0) nextY = plat.y + plat.height;
              this.dy = 0;
            }
          }
          this.x = nextX;
          this.y = nextY;
        }
        drawEyes(ctx, targetX, targetY, color) {
          const es = 4;
          const esp = 6;
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 3;
          const lx = targetX - cx;
          const ly = targetY - cy;
          const mm = 3;
          const d = Math.sqrt(lx * lx + ly * ly) || 1;
          const mx = (lx / d) * mm;
          const my = (ly / d) * mm;
          ctx.fillStyle = color;
          ctx.shadowBlur = 0;
          ctx.fillRect(cx - esp + mx - es / 2, cy + my - es / 2, es, es);
          ctx.fillRect(cx + esp + mx - es / 2, cy + my - es / 2, es, es);
        }
      }

      class Player extends Entity {
        constructor() {
          super(100, 900, 24, 24, Config.COLORS.PLAYER);

          // Use Config.PHYSICS.RUN_SPEED instead of hardcoded speed
          this.wallJumpsMax = 3;
          this.wallJumps = 3;
          this.health = 100;
          this.maxHealth = 100;
          this.dashes = 3;
          this.maxDashes = 3;
          this.dashCooldownTimer = 0;
          this.isDashing = false;
          this.dashFrameTimer = 0;
          this.lastShotTime = 0;
          this.shootCooldown = 120;
          this.dashDir = { x: 0, y: 0 };

          // INPUT BUFFERING
          this.coyoteTimer = 0;
          this.jumpBufferTimer = 0;
        }

        update(context) {
          const input = context.input;
          const P = Config.PHYSICS;

          // --- INPUT BUFFERING ---
          // Coyote Time
          if (this.onGround) {
            this.coyoteTimer = 6;
          } else {
            this.coyoteTimer--;
          }

          // Jump Buffer
          if (input.isPressed("w")) {
            this.jumpBufferTimer = 5;
          } else {
            this.jumpBufferTimer--;
          }

          // 1. VARIABLE JUMP HEIGHT (Cut velocity if button released)
          if (!input.isDown("w") && this.dy < -3 && !this.isDashing) {
            this.dy *= P.JUMP_CUTOFF;
          }

          // 2. DASH REGENERATION
          if (this.dashes < this.maxDashes) {
            this.dashCooldownTimer++;
            if (this.dashCooldownTimer >= P.DASH_REGEN_TIME) {
              this.dashes++;
              this.dashCooldownTimer = 0;
            }
          }

          // 3. DASH ACTIVATION
          if (input.isPressed("shift") && this.dashes > 0 && !this.isDashing) {
            this.isDashing = true;
            this.dashes--;
            this.dashFrameTimer = P.DASH_DURATION;
            this.dashCooldownTimer = 0;

            // Determine Direction
            let dx = 0;
            let dy = 0;
            if (input.isDown("w")) dy = -1;
            if (input.isDown("s")) dy = 1;
            if (input.isDown("a")) dx = -1;
            if (input.isDown("d")) dx = 1;

            // Default to facing
            if (dx === 0 && dy === 0) dx = this.facing === "left" ? -1 : 1;

            // Normalize
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len !== 0) {
              dx /= len;
              dy /= len;
            }

            this.dashDir = { x: dx, y: dy };

            // APPLY INSTANT VELOCITY
            this.dx = this.dashDir.x * P.DASH_SPEED;
            this.dy = this.dashDir.y * P.DASH_SPEED;

            context.camera.shake(4);
            context.game.freezeFrames = 3;
            context.particles.emitGhost(
              this.x,
              this.y,
              this.width,
              this.height,
              Config.COLORS.DASH_ACTIVE
            );
          }

          // 4. PHYSICS ENGINE
          if (this.isDashing) {
            // --- DASH STATE ---
            this.dashFrameTimer--;

            // Lock velocity to dash direction (no gravity, no friction)
            this.dx = this.dashDir.x * P.DASH_SPEED;
            this.dy = this.dashDir.y * P.DASH_SPEED;

            if (this.dashFrameTimer % 2 === 0) {
              context.particles.emitGhost(
                this.x,
                this.y,
                this.width,
                this.height,
                "rgba(255, 255, 255, 0.5)"
              );
            }

            // END OF DASH
            if (this.dashFrameTimer <= 0) {
              this.isDashing = false;
              // MOMENTUM KEY: We do NOT set dx to 0.
              // We let the 'Normal State' below handle the slowdown naturally.
              // We just dampen slightly so it's not uncontrollable.
              this.dx *= 0.8;
              this.dy *= 0.5;
            }

            // Dash Collision Check
            let nextX = this.x + this.dx;
            let nextY = this.y + this.dy;
            let hitWall = false;
            let hitFloor = false;

            // Check X first
            for (const plat of context.level.platforms) {
              if (
                Utils.checkAABB(
                  {
                    x: nextX,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                  },
                  plat
                )
              ) {
                // Hit Wall
                this.dx = 0;
                hitWall = true;
                nextX = this.x; // Cancel X movement
              }
            }

            // Check Y
            for (const plat of context.level.platforms) {
              if (
                Utils.checkAABB(
                  {
                    x: nextX,
                    y: nextY,
                    width: this.width,
                    height: this.height,
                  },
                  plat
                )
              ) {
                if (this.dy > 0) {
                  // Hit Floor
                  hitFloor = true;
                  nextY = plat.y - this.height;
                  this.dy = 0;
                } else if (this.dy < 0) {
                  // Hit Ceiling
                  this.dy = 0;
                  nextY = plat.y + plat.height;
                }
              }
            }

            if (hitWall) {
              this.isDashing = false;
            }

            if (hitFloor) {
              // If we hit the floor while dashing down-diag, we want to slide (Hyper)
              // So we end the dash state, but keep the X momentum.
              this.isDashing = false;
              this.onGround = true; // Important for friction logic next frame
            }

            this.x = nextX;
            this.y = nextY;
          } else {
            // --- NORMAL STATE (MOMENTUM BASED) ---

            // 1. Get Input Direction
            let dir = 0;
            if (input.isDown("a")) {
              dir = -1;
              this.facing = "left";
            } else if (input.isDown("d")) {
              dir = 1;
              this.facing = "right";
            }

            // 2. Apply Acceleration & Soft Cap
            if (dir !== 0) {
              if (
                Math.abs(this.dx) > P.RUN_SPEED &&
                Math.sign(this.dx) === dir
              ) {
                // Soft Cap: Don't add accel, just friction
                const friction = this.onGround
                  ? P.GROUND_FRICTION
                  : P.AIR_RESISTANCE;
                this.dx *= friction;
              } else {
                // Normal Acceleration
                this.dx += dir * P.ACCEL;
                // Clamp if we just exceeded RunSpeed
                if (
                  Math.abs(this.dx) > P.RUN_SPEED &&
                  Math.sign(this.dx) === dir
                ) {
                  this.dx = dir * P.RUN_SPEED;
                }
              }
            } else {
              // 3. Apply Friction (No Input)
              const friction = this.onGround
                ? P.GROUND_FRICTION
                : P.AIR_RESISTANCE;
              this.dx *= friction;
              if (Math.abs(this.dx) < 0.1) this.dx = 0;
            }

            // Jumping (Buffered)
            if (this.jumpBufferTimer > 0 && this.coyoteTimer > 0) {
              this._jump(context, false);
              this.jumpBufferTimer = 0;
              this.coyoteTimer = 0;
            }

            if (this.onGround) {
              this.wallJumps = this.wallJumpsMax;
            }

            if (this.onWall && this.wallJumps > 0) {
              if (input.isPressed("w")) this._jump(context, true);
            }

            this.updatePhysics(context.level, context);
          }

          // 5. COMBAT & BOUNDS
          if (input.mouse.down) {
            const now = Date.now();
            if (now - this.lastShotTime > this.shootCooldown) {
              this._shoot(context);
              this.lastShotTime = now;
            }
          }

          if (this.x < 0) this.x = 0;
          if (this.x > Config.WORLD.WIDTH - this.width)
            this.x = Config.WORLD.WIDTH - this.width;
          if (this.y > Config.WORLD.HEIGHT + 100) this.health = 0;
        }

        _jump(context, isWall) {
          const P = Config.PHYSICS;

          if (isWall) {
            // --- WALL JUMP ---
            const input = context.input;

            if (this.isDashing && this.dashDir.y < 0) {
              // WALL BOUNCE
              this.isDashing = false;
              this.dy = P.JUMP_POWER * 1.3; // Super vertical boost
              // Keep dx as is (likely 0 from collision)
            } else if (!input.isDown("a") && !input.isDown("d")) {
              // NEUTRAL WALL JUMP
              this.dy = P.JUMP_POWER;
              this.dx = this.onWall === "left" ? 3 : -3;
            } else {
              // NORMAL WALL JUMP
              this.dy = P.JUMP_POWER;
              this.dx = this.onWall === "left" ? 6 : -6;
            }

            this.wallJumps--;
            this.facing = this.onWall === "left" ? "right" : "left";
            context.particles.emitDust(
              this.onWall === "left" ? this.x : this.x + this.width,
              this.y + this.height / 2
            );
          } else {
            // --- GROUND JUMP ---
            if (this.isDashing) {
              // MOMENTUM CONVERSION
              this.isDashing = false;

              if (this.dashDir.y > 0) {
                // HYPER DASH (Down-Diagonal)
                // Lower jump, higher speed
                this.dy = P.JUMP_POWER * 0.6;
                this.dx *= 1.2;
                // WAVE DASH: Refill dash immediately
                this.dashes = this.maxDashes;
              } else {
                // SUPER DASH (Horizontal)
                // Full jump, keep dash speed
                this.dy = P.JUMP_POWER;
              }
            } else {
              // NORMAL JUMP
              this.dy = P.JUMP_POWER;
            }
            context.particles.emitDust(
              this.x + this.width / 2,
              this.y + this.height
            );
          }

          this.scaleX = 0.6;
          this.scaleY = 1.4;
        }

        // ... _shoot and draw methods remain unchanged ...
        _shoot(context) {
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const worldMouseX = context.input.mouse.x + context.camera.x;
          const worldMouseY = context.input.mouse.y + context.camera.y;
          const angle = Utils.getAngle(cx, cy, worldMouseX, worldMouseY);
          const speed = 12;
          context.bullets.push({
            x: cx,
            y: cy,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            isPlayer: true,
            radius: 3,
          });
          context.camera.shake(2);
          context.particles.emitExplosion(
            cx + Math.cos(angle) * 15,
            cy + Math.sin(angle) * 15,
            "#fff"
          );
        }

        draw(ctx, mouse, camera) {
          ctx.save();
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height;

          ctx.translate(cx, cy);
          ctx.scale(this.scaleX, this.scaleY);
          ctx.translate(-cx, -cy);

          ctx.fillStyle = this.isDashing ? "#fff" : this.color;
          ctx.shadowBlur = 6;
          ctx.shadowColor = this.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);

          this.drawEyes(
            ctx,
            mouse.x + camera.x,
            mouse.y + camera.y,
            Config.COLORS.PLAYER_EYES
          );

          ctx.restore();
        }
      }

      class Enemy extends Entity {
        constructor(x, y) {
          super(x, y, 24, 24, Config.COLORS.ENEMY);
          this.health = 100;
          this.maxHealth = 100;
          this.hitFlashTimer = 0;
        }
        update(context, player) {
          this.dx *= Config.PHYSICS.FRICTION;
          this.updatePhysics(context.level, context);
        }
        takeDamage(amount) {
          this.health -= amount;
          this.hitFlashTimer = 5;
        }
        draw(ctx, player) {
          ctx.fillStyle = this.hitFlashTimer > 0 ? "#fff" : this.color;
          if (this.hitFlashTimer > 0) this.hitFlashTimer--;
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color;
          ctx.fillRect(this.x, this.y, this.width, this.height);
          const tx = player.x + player.width / 2;
          const ty = player.y + player.height / 2;
          this.drawEyes(ctx, tx, ty, Config.COLORS.ENEMY_EYES);
          const hpPct = Math.max(0, this.health / this.maxHealth);
          ctx.shadowBlur = 0;
          ctx.fillStyle = "#333";
          ctx.fillRect(this.x, this.y - 8, this.width, 3);
          ctx.fillStyle = "#f00";
          ctx.fillRect(this.x, this.y - 8, this.width * hpPct, 3);
        }
      }

      // ================== GAME LOGIC ==================
      class Level {
        constructor() {
          const w = Config.WORLD.WIDTH;
          const h = Config.WORLD.HEIGHT;

          this.platforms = [
            { x: -40, y: 0, width: 40, height: h }, // Left Wall
            { x: w, y: 0, width: 40, height: h }, // Right Wall
            { x: 0, y: -40, width: w, height: 40 }, // Ceiling
            { x: 0, y: h - 40, width: w, height: 80 }, // The Floor

            // Bottom Zone
            { x: 0, y: 1000, width: 250, height: 20 },
            { x: 250, y: 900, width: 20, height: 120 },
            { x: 400, y: 950, width: 150, height: 20 },
            { x: 700, y: 850, width: 150, height: 20 },
            { x: 1000, y: 950, width: 150, height: 20 },
            { x: 1700, y: 600, width: 20, height: 600 }, // Shaft
            { x: 1850, y: 800, width: 100, height: 20 },

            // Mid
            { x: 150, y: 750, width: 400, height: 20 },
            { x: 800, y: 650, width: 400, height: 20 },
            { x: 600, y: 500, width: 20, height: 250 },
            { x: 1200, y: 500, width: 20, height: 250 },

            // High
            { x: 200, y: 550, width: 150, height: 20 },
            { x: 50, y: 400, width: 200, height: 20 },
            { x: 650, y: 350, width: 200, height: 20 },
            { x: 1050, y: 350, width: 200, height: 20 },
            { x: 1500, y: 250, width: 400, height: 20 },
            { x: 1400, y: 150, width: 20, height: 120 },
          ];
        }

        draw(ctx) {
          ctx.beginPath();
          for (const p of this.platforms) ctx.rect(p.x, p.y, p.width, p.height);
          ctx.fillStyle = Config.COLORS.WALL;
          ctx.shadowColor = Config.COLORS.WALL_GLOW;
          ctx.shadowBlur = 10;
          ctx.fill();
          ctx.shadowBlur = 0;
        }
      }

      class Camera {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.shakePower = 0;
        }
        shake(amount) {
          this.shakePower = amount;
        }

        update(player, canvasWidth, canvasHeight) {
          let targetX = player.x + player.width / 2 - canvasWidth / 2;
          let targetY = player.y + player.height / 2 - canvasHeight / 2;
          targetX = Math.max(
            0,
            Math.min(targetX, Config.WORLD.WIDTH - canvasWidth)
          );
          targetY = Math.max(
            0,
            Math.min(targetY, Config.WORLD.HEIGHT - canvasHeight)
          );
          this.x += (targetX - this.x) * 0.1;
          this.y += (targetY - this.y) * 0.1;

          if (this.shakePower > 0) {
            this.x += Utils.rand(-this.shakePower, this.shakePower);
            this.y += Utils.rand(-this.shakePower, this.shakePower);
            this.shakePower *= 0.9;
            if (this.shakePower < 0.5) this.shakePower = 0;
          }
        }
      }

      class Game {
        constructor() {
          this.canvas = document.getElementById("game");
          this.ctx = this.canvas.getContext("2d");
          this.input = new InputHandler(this.canvas);
          this.camera = new Camera();
          this.particles = new ParticleSystem();
          this.level = new Level();
          this.reset();
          this.ui = new UIManager(
            this.player.wallJumpsMax,
            this.player.maxDashes
          );
          this.freezeFrames = 0;
          this.loop = this.loop.bind(this);
          requestAnimationFrame(this.loop);
        }

        reset() {
          this.player = new Player();
          this.enemies = [new Enemy(600, 370)];
          this.bullets = [];
        }

        get context() {
          return {
            input: this.input,
            camera: this.camera,
            particles: this.particles,
            level: this.level,
            bullets: this.bullets,
            game: this,
          };
        }

        update() {
          this.camera.update(
            this.player,
            this.canvas.width,
            this.canvas.height
          );
          this.particles.update();
          this.player.update(this.context);
          this.enemies.forEach((e) => e.update(this.context, this.player));
          this.updateBullets();
          this.ui.update(this.player);
          this.input.clearFrame();
        }

        updateBullets() {
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.dx;
            b.y += b.dy;

            this.particles.emitTrail(
              b.x,
              b.y,
              b.isPlayer ? Config.COLORS.PLAYER : Config.COLORS.ENEMY,
              b.radius
            );

            if (
              b.x < 0 ||
              b.x > Config.WORLD.WIDTH ||
              b.y < 0 ||
              b.y > Config.WORLD.HEIGHT
            ) {
              this.bullets.splice(i, 1);
              continue;
            }

            let hitPlat = false;
            for (let plat of this.level.platforms) {
              if (
                Utils.checkAABB(
                  {
                    x: b.x - b.radius,
                    y: b.y - b.radius,
                    width: b.radius * 2,
                    height: b.radius * 2,
                  },
                  plat
                )
              ) {
                hitPlat = true;
                this.particles.emitExplosion(b.x, b.y, "#ccc");
                break;
              }
            }
            if (hitPlat) {
              this.bullets.splice(i, 1);
              continue;
            }

            if (b.isPlayer) {
              for (let j = this.enemies.length - 1; j >= 0; j--) {
                let e = this.enemies[j];
                if (
                  Utils.checkAABB(
                    { x: b.x, y: b.y, width: b.radius, height: b.radius },
                    e
                  )
                ) {
                  e.takeDamage(20);
                  this.particles.emitExplosion(b.x, b.y, Config.COLORS.ENEMY);
                  this.bullets.splice(i, 1);
                  if (e.health <= 0) {
                    this.particles.emitExplosion(
                      e.x + 12,
                      e.y + 12,
                      Config.COLORS.ENEMY
                    );
                    e.health = e.maxHealth;
                  }
                  break;
                }
              }
            }
          }
        }

        draw() {
          this.ctx.fillStyle = Config.COLORS.BG;
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          this.ctx.save();
          this.ctx.translate(-this.camera.x, -this.camera.y);

          this.level.draw(this.ctx);
          this.particles.draw(this.ctx);
          this.enemies.forEach((e) => e.draw(this.ctx, this.player));
          this.player.draw(this.ctx, this.input.mouse, this.camera);

          for (let b of this.bullets) {
            this.ctx.fillStyle = b.isPlayer ? "#fff" : "#ffaaaa";
            this.ctx.shadowBlur = 8;
            this.ctx.shadowColor = b.isPlayer
              ? Config.COLORS.PLAYER
              : Config.COLORS.ENEMY;
            this.ctx.beginPath();
            this.ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            this.ctx.fill();
          }

          this.ctx.restore();

          this.ctx.shadowBlur = 4;
          this.ctx.shadowColor = "#fff";
          this.ctx.strokeStyle = "#fff";
          this.ctx.lineWidth = 1;
          const mx = this.input.mouse.x;
          const my = this.input.mouse.y;

          this.ctx.strokeRect(mx - 6, my - 6, 12, 12);
          this.ctx.beginPath();
          this.ctx.moveTo(mx, my - 2);
          this.ctx.lineTo(mx, my + 2);
          this.ctx.moveTo(mx - 2, my);
          this.ctx.lineTo(mx + 2, my);
          this.ctx.stroke();
        }

        loop() {
          if (this.freezeFrames > 0) {
            this.freezeFrames--;
            requestAnimationFrame(this.loop);
            return;
          }
          this.update();
          this.draw();
          requestAnimationFrame(this.loop);
        }
      }

      const game = new Game();
    </script>
  </body>
</html>
