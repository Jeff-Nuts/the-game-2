<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Neon Square - SOLID Refactor</title>
    <style>
      /* --- RESET & LAYOUT --- */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #050505;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        color: #fff;
        font-family: "Segoe UI", sans-serif;
        user-select: none;
      }

      /* --- MAIN GAME CONTAINER --- */
      #game-container {
        position: relative;
        width: 800px;
        height: 450px;
        background: #000;
        box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
        overflow: hidden;
      }

      /* LAYER 0: CANVAS */
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        display: block;
        width: 100%;
        height: 100%;
        background: #0a0a10;
        cursor: none;
        z-index: 0;
      }

      /* LAYER 1: UI HUD */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      #ui-panel {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 220px;
        height: 100px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 12px;
      }

      .ui-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
        font-weight: bold;
      }
      .label {
        color: #fff;
        margin-right: 10px;
        min-width: 70px;
      }

      .hp-container {
        flex-grow: 1;
        height: 12px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      #hp-fill {
        height: 100%;
        width: 100%;
        background-color: #ffff00;
        transition: width 0.1s linear, background-color 0.2s;
      }

      .pips-container {
        display: flex;
        gap: 4px;
      }
      .pip {
        width: 15px;
        height: 10px;
        background-color: #333;
        border-radius: 1px;
        transition: background-color 0.1s;
      }
      .pip.jump-active {
        background-color: #ffff00;
        box-shadow: 0 0 5px #ffff00;
      }
      .pip.dash-active {
        background-color: #00f3ff;
        box-shadow: 0 0 5px #00f3ff;
      }

      /* LAYER 2: CINEMATIC */
      #cinematic-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      #cinematic-layer.active {
        opacity: 1;
      }

      .cine-bar {
        width: 100%;
        height: 0;
        background-color: #000;
        transition: height 0.5s ease;
      }

      #cinematic-layer.active .cine-bar {
        height: 60px;
      }

      #dialogue-box {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 600px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #fff;
        padding: 20px;
        text-align: center;
        font-family: "Courier New", monospace;
        display: none;
      }
      #cinematic-layer.active #dialogue-box {
        display: block;
      }

      /* LAYER 3: GLOBAL FADE */
      #fade-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 30;
        opacity: 0;
        pointer-events: none;
        transition: opacity 1s ease;
      }
      #fade-overlay.black {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <canvas id="game" width="800" height="450"></canvas>

      <div id="ui-layer">
        <div id="ui-panel">
          <div class="ui-row">
            <span class="label">HP</span>
            <div class="hp-container"><div id="hp-fill"></div></div>
          </div>
          <div class="ui-row">
            <span class="label">Wall Jumps</span>
            <div id="jumps-container" class="pips-container"></div>
          </div>
          <div class="ui-row">
            <span class="label">Dashes</span>
            <div id="dashes-container" class="pips-container"></div>
          </div>
        </div>
      </div>

      <div id="cinematic-layer">
        <div class="cine-bar top"></div>
        <div id="dialogue-box">System Initialized...</div>
        <div class="cine-bar bottom"></div>
      </div>

      <div id="fade-overlay"></div>
    </div>

    <script>
      /**
       * SOLID PRINCIPLES APPLIED:
       *
       * 1. Single Responsibility Principle (SRP):
       *    - PhysicsSystem: Handles movement and collision.
       *    - RenderSystem: Handles drawing.
       *    - InputHandler: Handles raw input.
       *    - PlayerController: Maps input to player actions.
       *    - UIManager: Handles DOM UI updates.
       *    - ParticleSystem: Handles visual effects.
       *
       * 2. Open/Closed Principle (OCP):
       *    - The Game class iterates over generic IGameObject lists.
       *    - New entities (e.g., Traps, Powerups) can be added by extending Entity
       *      without modifying the main game loop or PhysicsSystem.
       *
       * 3. Liskov Substitution Principle (LSP):
       *    - All entities (Player, Enemy, Bullet) inherit from Entity/Actor and
       *      can be treated uniformly by the PhysicsSystem and RenderSystem.
       *
       * 4. Interface Segregation Principle (ISP):
       *    - (Simulated via Duck Typing/Composition)
       *    - Not all objects need health (Bullets vs Actors).
       *    - Not all objects need eyes (Bullets vs Actors).
       *    - RenderSystem checks for capabilities before drawing.
       *
       * 5. Dependency Inversion Principle (DIP):
       *    - Entities depend on the abstract 'GameContext' interface (injected),
       *      not on the concrete Game class instance directly.
       */

      // ================== CONFIGURATION ==================
      class Config {
        static PHYSICS = {
          GRAVITY: 0.6,
          RUN_SPEED: 4.0,
          ACCEL: 1.5,
          GROUND_FRICTION: 0.8,
          AIR_RESISTANCE: 0.97,
          WALL_SLIDE_SPEED: 2,
          TERMINAL_VELOCITY: 18,
          DASH_SPEED: 18.0,
          DASH_DURATION: 10,
          DASH_REGEN_TIME: 30,
          JUMP_POWER: -13,
          JUMP_CUTOFF: 0.5,
        };

        static WORLD = {
          WIDTH: 2000,
          HEIGHT: 1200,
        };

        static COLORS = {
          BG: "#0a0a10",
          PLAYER: "#FFFF00",
          PLAYER_EYES: "#000000",
          ENEMY: "#ff0055",
          ENEMY_EYES: "#330000",
          WALL: "#1e1e24",
          WALL_GLOW: "rgba(0, 0, 0, 0)",
          DASH_ACTIVE: "#00f3ff",
        };
      }

      // ================== UTILITIES ==================
      class Utils {
        static rand(min, max) {
          return Math.random() * (max - min) + min;
        }
        static lerp(start, end, amt) {
          return (1 - amt) * start + amt * end;
        }
        static checkAABB(rect1, rect2) {
          return (
            rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y
          );
        }
        static getAngle(x1, y1, x2, y2) {
          return Math.atan2(y2 - y1, x2 - x1);
        }
      }

      // ================== CORE SYSTEMS ==================

      // --- INPUT SYSTEM ---
      class InputHandler {
        constructor(canvas) {
          this.keys = {};
          this.keysPressed = {};
          this.mouse = { x: 0, y: 0, down: false };
          this.canvas = canvas;

          window.addEventListener("keydown", (e) => this._onKeyDown(e));
          window.addEventListener("keyup", (e) => this._onKeyUp(e));
          canvas.addEventListener("mousemove", (e) => this._onMouseMove(e));
          canvas.addEventListener("mousedown", (e) => this._onMouseDown(e));
          canvas.addEventListener("mouseup", (e) => this._onMouseUp(e));
        }

        _onKeyDown(e) {
          const k = e.key.toLowerCase();
          if (!this.keys[k]) this.keysPressed[k] = true;
          this.keys[k] = true;
        }
        _onKeyUp(e) {
          const k = e.key.toLowerCase();
          this.keys[k] = false;
          this.keysPressed[k] = false;
        }
        _onMouseMove(e) {
          const r = this.canvas.getBoundingClientRect();
          this.mouse.x = e.clientX - r.left;
          this.mouse.y = e.clientY - r.top;
        }
        _onMouseDown(e) {
          if (e.button === 0) this.mouse.down = true;
        }
        _onMouseUp(e) {
          if (e.button === 0) this.mouse.down = false;
        }

        isDown(key) {
          return !!this.keys[key];
        }
        isPressed(key) {
          return !!this.keysPressed[key];
        }
        clearFrame() {
          this.keysPressed = {};
        }
      }

      // --- PHYSICS SYSTEM ---
      class PhysicsSystem {
        constructor(level) {
          this.level = level;
        }

        applyGravity(entity) {
          entity.dy += Config.PHYSICS.GRAVITY;
        }

        applyFriction(entity) {
          const friction = entity.onGround
            ? Config.PHYSICS.GROUND_FRICTION
            : Config.PHYSICS.AIR_RESISTANCE;
          entity.dx *= friction;
          if (Math.abs(entity.dx) < 0.1) entity.dx = 0;
        }

        resolveCollisions(entity) {
          // Wall Slide Logic
          if (entity.onWall && entity.dy > 0 && !entity.onGround) {
            entity.dy = Config.PHYSICS.WALL_SLIDE_SPEED;
          }

          let nextX = entity.x + entity.dx;
          let nextY = entity.y + entity.dy;

          entity.onGround = false;
          entity.onWall = false; // "left" | "right" | false

          // Horizontal Collision
          for (const plat of this.level.platforms) {
            if (
              Utils.checkAABB(
                {
                  x: nextX,
                  y: entity.y,
                  width: entity.width,
                  height: entity.height,
                },
                plat
              )
            ) {
              if (entity.dx > 0) {
                nextX = plat.x - entity.width;
                entity.onWall = "right";
              } else if (entity.dx < 0) {
                nextX = plat.x + plat.width;
                entity.onWall = "left";
              }
              entity.dx = 0;
            }
          }

          // Vertical Collision
          for (const plat of this.level.platforms) {
            if (
              Utils.checkAABB(
                {
                  x: nextX,
                  y: nextY,
                  width: entity.width,
                  height: entity.height,
                },
                plat
              )
            ) {
              if (entity.dy > 0) {
                nextY = plat.y - entity.height;
                entity.onGround = true;
              } else if (entity.dy < 0) {
                nextY = plat.y + plat.height;
              }
              entity.dy = 0;
            }
          }

          entity.x = nextX;
          entity.y = nextY;

          // World Bounds
          if (entity.x < 0) entity.x = 0;
          if (entity.x > Config.WORLD.WIDTH - entity.width)
            entity.x = Config.WORLD.WIDTH - entity.width;
        }
      }

      // --- RENDER SYSTEM ---
      class RenderSystem {
        constructor(ctx, camera) {
          this.ctx = ctx;
          this.camera = camera;
        }

        clear(width, height) {
          this.ctx.fillStyle = Config.COLORS.BG;
          this.ctx.fillRect(0, 0, width, height);
        }

        begin() {
          this.ctx.save();
          this.ctx.translate(-this.camera.x, -this.camera.y);
        }

        end() {
          this.ctx.restore();
        }

        drawLevel(level) {
          this.ctx.beginPath();
          for (const p of level.platforms) {
            this.ctx.rect(p.x, p.y, p.width, p.height);
          }
          this.ctx.fillStyle = Config.COLORS.WALL;
          this.ctx.shadowColor = Config.COLORS.WALL_GLOW;
          this.ctx.shadowBlur = 10;
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
        }

        drawEntity(entity, targetPoint) {
          this.ctx.save();
          const cx = entity.x + entity.width / 2;
          const cy = entity.y + entity.height;

          this.ctx.translate(cx, cy);
          this.ctx.scale(entity.scaleX, entity.scaleY);
          this.ctx.translate(-cx, -cy);

          this.ctx.fillStyle = entity.color;
          // Flash effect for damage
          if (entity.hitFlashTimer > 0) {
            this.ctx.fillStyle = "#fff";
          }
          // Dash effect override
          if (entity.isDashing) {
            this.ctx.fillStyle = "#fff";
          }

          this.ctx.shadowBlur = 6;
          this.ctx.shadowColor = entity.color;
          this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);

          // Draw Eyes if applicable
          if (entity.hasEyes) {
            const targetX = targetPoint ? targetPoint.x : entity.x;
            const targetY = targetPoint ? targetPoint.y : entity.y;
            this._drawEyes(
              entity,
              targetX,
              targetY,
              entity.eyeColor || "#000"
            );
          }

          // Draw Health Bar if applicable
          if (entity.showHealthBar) {
            this._drawHealthBar(entity);
          }

          this.ctx.restore();
        }

        _drawEyes(entity, targetX, targetY, color) {
          const es = 4;
          const esp = 6;
          const cx = entity.x + entity.width / 2;
          const cy = entity.y + entity.height / 3;
          const lx = targetX - cx;
          const ly = targetY - cy;
          const mm = 3;
          const d = Math.sqrt(lx * lx + ly * ly) || 1;
          const mx = (lx / d) * mm;
          const my = (ly / d) * mm;
          this.ctx.fillStyle = color;
          this.ctx.shadowBlur = 0;
          this.ctx.fillRect(cx - esp + mx - es / 2, cy + my - es / 2, es, es);
          this.ctx.fillRect(cx + esp + mx - es / 2, cy + my - es / 2, es, es);
        }

        _drawHealthBar(entity) {
          const hpPct = Math.max(0, entity.health / entity.maxHealth);
          this.ctx.shadowBlur = 0;
          this.ctx.fillStyle = "#333";
          this.ctx.fillRect(entity.x, entity.y - 8, entity.width, 3);
          this.ctx.fillStyle = "#f00";
          this.ctx.fillRect(entity.x, entity.y - 8, entity.width * hpPct, 3);
        }

        drawBullet(bullet) {
          this.ctx.fillStyle = bullet.isPlayer ? "#fff" : "#ffaaaa";
          this.ctx.shadowBlur = 8;
          this.ctx.shadowColor = bullet.isPlayer
            ? Config.COLORS.PLAYER
            : Config.COLORS.ENEMY;
          this.ctx.beginPath();
          this.ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          this.ctx.fill();
        }

        drawCursor(mouse) {
          this.ctx.shadowBlur = 4;
          this.ctx.shadowColor = "#fff";
          this.ctx.strokeStyle = "#fff";
          this.ctx.lineWidth = 1;
          const mx = mouse.x;
          const my = mouse.y;

          this.ctx.strokeRect(mx - 6, my - 6, 12, 12);
          this.ctx.beginPath();
          this.ctx.moveTo(mx, my - 2);
          this.ctx.lineTo(mx, my + 2);
          this.ctx.moveTo(mx - 2, my);
          this.ctx.lineTo(mx + 2, my);
          this.ctx.stroke();
        }
      }

      // --- PARTICLE SYSTEM ---
      class Particle {
        constructor(x, y, type, color, size = null) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.color = color;
          this.life = 1.0;
          this.size = size;
          this._initPhysics();
        }
        _initPhysics() {
          const angle = Utils.rand(0, Math.PI * 2);
          if (this.type === "dust") {
            this.dx = Math.cos(angle) * 0.5;
            this.dy = -Utils.rand(0.5, 2);
            this.decay = 0.04;
            this.size = this.size || Utils.rand(2, 4);
          } else if (this.type === "spark") {
            const speed = 3;
            this.dx = Math.cos(angle) * speed;
            this.dy = Math.sin(angle) * speed;
            this.decay = 0.06;
            this.size = this.size || Utils.rand(2, 5);
          } else if (this.type === "trail") {
            this.dx = 0;
            this.dy = 0;
            this.decay = 0.1;
            this.size = this.size || Utils.rand(2, 4);
          }
        }
        update() {
          this.x += this.dx;
          this.y += this.dy;
          this.life -= this.decay;
          if (this.type === "spark") {
            this.dy += 0.2;
            this.dx *= 0.95;
          }
        }
        draw(ctx) {
          ctx.globalAlpha = Math.max(0, this.life);
          ctx.fillStyle = this.color;
          ctx.shadowBlur = this.type === "spark" ? 10 : 0;
          ctx.shadowColor = this.color;
          ctx.fillRect(
            this.x - this.size / 2,
            this.y - this.size / 2,
            this.size,
            this.size
          );
          ctx.globalAlpha = 1.0;
          ctx.shadowBlur = 0;
        }
      }

      class ParticleSystem {
        constructor() {
          this.particles = [];
        }
        update() {
          for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
          }
        }
        draw(ctx) {
          this.particles.forEach((p) => p.draw(ctx));
        }
        emitDust(x, y) {
          for (let i = 0; i < 4; i++)
            this.particles.push(new Particle(x, y, "dust", "#888"));
        }
        emitExplosion(x, y, color) {
          for (let i = 0; i < 12; i++)
            this.particles.push(new Particle(x, y, "spark", color));
        }
        emitTrail(x, y, color, size) {
          if (Math.random() > 0.3)
            this.particles.push(new Particle(x, y, "trail", color, size));
        }
        emitGhost(x, y, width, height, color) {
          const p = new Particle(
            x + width / 2,
            y + height / 2,
            "trail",
            color,
            width
          );
          p.decay = 0.15;
          this.particles.push(p);
        }
      }

      // --- UI MANAGER ---
      class UIManager {
        constructor() {
          this.uiLayer = document.getElementById("ui-layer");
          this.cinematicLayer = document.getElementById("cinematic-layer");
          this.fadeOverlay = document.getElementById("fade-overlay");
          this.hpFill = document.getElementById("hp-fill");
          this.jumpsContainer = document.getElementById("jumps-container");
          this.dashesContainer = document.getElementById("dashes-container");
          this.jumpPips = [];
          this.dashPips = [];
        }

        init(maxJumps, maxDashes) {
          this._createPips(this.jumpsContainer, this.jumpPips, maxJumps);
          this._createPips(this.dashesContainer, this.dashPips, maxDashes);
        }

        _createPips(container, array, count) {
          container.innerHTML = "";
          array.length = 0;
          for (let i = 0; i < count; i++) {
            const pip = document.createElement("div");
            pip.className = "pip";
            container.appendChild(pip);
            array.push(pip);
          }
        }

        update(player) {
          const hpPct = Math.max(0, player.health / player.maxHealth) * 100;
          this.hpFill.style.width = `${hpPct}%`;
          this.hpFill.style.backgroundColor =
            hpPct > 30 ? Config.COLORS.PLAYER : "#ff0000";

          this.jumpPips.forEach((pip, i) => {
            if (i < player.wallJumps) pip.classList.add("jump-active");
            else pip.classList.remove("jump-active");
          });
          this.dashPips.forEach((pip, i) => {
            if (i < player.dashes) pip.classList.add("dash-active");
            else pip.classList.remove("dash-active");
          });
        }
      }

      // --- CAMERA ---
      class Camera {
        constructor() {
          this.x = 0;
          this.y = 0;
          this.shakePower = 0;
        }
        shake(amount) {
          this.shakePower = amount;
        }
        update(target, canvasWidth, canvasHeight) {
          let targetX = target.x + target.width / 2 - canvasWidth / 2;
          let targetY = target.y + target.height / 2 - canvasHeight / 2;
          targetX = Math.max(
            0,
            Math.min(targetX, Config.WORLD.WIDTH - canvasWidth)
          );
          targetY = Math.max(
            0,
            Math.min(targetY, Config.WORLD.HEIGHT - canvasHeight)
          );
          this.x += (targetX - this.x) * 0.1;
          this.y += (targetY - this.y) * 0.1;

          if (this.shakePower > 0) {
            this.x += Utils.rand(-this.shakePower, this.shakePower);
            this.y += Utils.rand(-this.shakePower, this.shakePower);
            this.shakePower *= 0.9;
            if (this.shakePower < 0.5) this.shakePower = 0;
          }
        }
      }

      // ================== GAME OBJECTS ==================

      class GameObject {
        constructor(x, y, w, h) {
          this.x = x;
          this.y = y;
          this.width = w;
          this.height = h;
          this.markedForDeletion = false;
        }
        update(context) {}
      }

      class Entity extends GameObject {
        constructor(x, y, w, h, color) {
          super(x, y, w, h);
          this.color = color;
          this.dx = 0;
          this.dy = 0;
          this.onGround = false;
          this.onWall = false;
          this.scaleX = 1;
          this.scaleY = 1;
          this.facing = "right";
          this.isDashing = false;
          this.hitFlashTimer = 0;
          this.hasEyes = false;
          this.showHealthBar = false;
        }

        updateAnimation() {
          this.scaleX = Utils.lerp(this.scaleX, 1, 0.2);
          this.scaleY = Utils.lerp(this.scaleY, 1, 0.2);
          if (this.hitFlashTimer > 0) this.hitFlashTimer--;
        }
      }

      class Actor extends Entity {
        constructor(x, y, w, h, color, health) {
          super(x, y, w, h, color);
          this.health = health;
          this.maxHealth = health;
        }
        takeDamage(amount) {
          this.health -= amount;
          this.hitFlashTimer = 5;
        }
      }

      // --- PLAYER ---
      class Player extends Actor {
        constructor() {
          super(100, 900, 24, 24, Config.COLORS.PLAYER, 100);
          this.hasEyes = true;
          this.eyeColor = Config.COLORS.PLAYER_EYES;

          // Stats
          this.wallJumpsMax = 3;
          this.wallJumps = 3;
          this.maxDashes = 1;
          this.dashes = 1;

          // State
          this.dashFrameTimer = 0;
          this.dashDir = { x: 0, y: 0 };
          this.lastShotTime = 0;
          this.shootCooldown = 120;

          // Input Buffers
          this.coyoteTimer = 0;
          this.jumpBufferTimer = 0;
        }

        update(context) {
          this.updateAnimation();
          this._handleInput(context);
          this._handlePhysics(context);
          this._checkWorldBounds();
        }

        _handleInput(context) {
          const input = context.input;
          const P = Config.PHYSICS;

          // Buffers
          if (this.onGround) this.coyoteTimer = 6;
          else this.coyoteTimer--;

          if (input.isPressed("w")) this.jumpBufferTimer = 5;
          else this.jumpBufferTimer--;

          // Variable Jump
          if (!input.isDown("w") && this.dy < -3 && !this.isDashing) {
            this.dy *= P.JUMP_CUTOFF;
          }

          // Dash Trigger
          if (input.isPressed("shift") && this.dashes > 0 && !this.isDashing) {
            this._startDash(context);
          }

          // Shooting
          if (input.mouse.down) {
            const now = Date.now();
            if (now - this.lastShotTime > this.shootCooldown) {
              this._shoot(context);
              this.lastShotTime = now;
            }
          }
        }

        _startDash(context) {
          const input = context.input;
          const P = Config.PHYSICS;

          this.isDashing = true;
          this.dashes--;
          this.dashFrameTimer = P.DASH_DURATION;

          let dx = 0;
          let dy = 0;
          if (input.isDown("w")) dy = -1;
          if (input.isDown("s")) dy = 1;
          if (input.isDown("a")) dx = -1;
          if (input.isDown("d")) dx = 1;
          if (dx === 0 && dy === 0) dx = this.facing === "left" ? -1 : 1;

          const len = Math.sqrt(dx * dx + dy * dy);
          if (len !== 0) {
            dx /= len;
            dy /= len;
          }

          this.dashDir = { x: dx, y: dy };
          this.dx = this.dashDir.x * P.DASH_SPEED;
          this.dy = this.dashDir.y * P.DASH_SPEED;

          context.camera.shake(4);
          context.game.freezeFrames = 3;
          context.particles.emitGhost(
            this.x,
            this.y,
            this.width,
            this.height,
            Config.COLORS.DASH_ACTIVE
          );
        }

        _handlePhysics(context) {
          const P = Config.PHYSICS;
          const input = context.input;

          if (this.isDashing) {
            this._updateDashPhysics(context);
          } else {
            // Normal Movement
            let dir = 0;
            if (input.isDown("a")) {
              dir = -1;
              this.facing = "left";
            } else if (input.isDown("d")) {
              dir = 1;
              this.facing = "right";
            }

            // Horizontal Movement
            if (dir !== 0) {
              if (
                Math.abs(this.dx) > P.RUN_SPEED &&
                Math.sign(this.dx) === dir
              ) {
                const friction = this.onGround
                  ? P.GROUND_FRICTION
                  : P.AIR_RESISTANCE;
                this.dx *= friction;
              } else {
                this.dx += dir * P.ACCEL;
                if (
                  Math.abs(this.dx) > P.RUN_SPEED &&
                  Math.sign(this.dx) === dir
                ) {
                  this.dx = dir * P.RUN_SPEED;
                }
              }
            } else {
              context.physics.applyFriction(this);
            }

            // Jump Execution
            if (this.jumpBufferTimer > 0 && this.coyoteTimer > 0) {
              this._jump(context, false);
              this.jumpBufferTimer = 0;
              this.coyoteTimer = 0;
            }

            // Wall Jump
            if (this.onWall && this.wallJumps > 0 && input.isPressed("w")) {
              this._jump(context, true);
            }

            context.physics.applyGravity(this);
            context.physics.resolveCollisions(this);

            // Land Effect
            if (this.onGround && this.dy === 0) {
              // Logic to detect landing frame could be improved, but this works
              // relying on previous frame dy is harder without storing it
              // For now, we rely on the physics system to set onGround.
              // We can check if we were in air last frame if we stored it.
            }

            // Refill resources
            if (this.onGround) {
              this.wallJumps = this.wallJumpsMax;
              this.dashes = this.maxDashes;
            }
          }
        }

        _updateDashPhysics(context) {
          this.dashFrameTimer--;
          this.dx = this.dashDir.x * Config.PHYSICS.DASH_SPEED;
          this.dy = this.dashDir.y * Config.PHYSICS.DASH_SPEED;

          if (this.dashFrameTimer % 2 === 0) {
            context.particles.emitGhost(
              this.x,
              this.y,
              this.width,
              this.height,
              "rgba(255, 255, 255, 0.5)"
            );
          }

          if (this.dashFrameTimer <= 0) {
            this.isDashing = false;
            this.dx *= 0.8;
            this.dy *= 0.5;
          }

          // Custom collision for dash (stops on wall)
          context.physics.resolveCollisions(this);
          if (this.dx === 0 && this.dashDir.x !== 0) this.isDashing = false; // Hit wall
          if (this.onGround && this.dashDir.y > 0) this.isDashing = false; // Hit floor
        }

        _jump(context, isWall) {
          const P = Config.PHYSICS;
          if (isWall) {
            this.dashes = this.maxDashes;
            const input = context.input;
            if (this.isDashing && this.dashDir.y < 0) {
              this.isDashing = false;
              this.dy = P.JUMP_POWER * 1.3;
            } else if (!input.isDown("a") && !input.isDown("d")) {
              this.dy = P.JUMP_POWER;
              this.dx = this.onWall === "left" ? 3 : -3;
            } else {
              this.dy = P.JUMP_POWER;
              this.dx = this.onWall === "left" ? 6 : -6;
            }
            this.wallJumps--;
            this.facing = this.onWall === "left" ? "right" : "left";
            context.particles.emitDust(
              this.onWall === "left" ? this.x : this.x + this.width,
              this.y + this.height / 2
            );
          } else {
            if (this.isDashing) {
              this.isDashing = false;
              if (this.dashDir.y > 0) {
                this.dy = P.JUMP_POWER * 0.6;
                this.dx *= 1.2;
                this.dashes = this.maxDashes;
              } else {
                this.dy = P.JUMP_POWER;
              }
            } else {
              this.dy = P.JUMP_POWER;
            }
            context.particles.emitDust(
              this.x + this.width / 2,
              this.y + this.height
            );
          }
          this.scaleX = 0.6;
          this.scaleY = 1.4;
        }

        _shoot(context) {
          const cx = this.x + this.width / 2;
          const cy = this.y + this.height / 2;
          const worldMouseX = context.input.mouse.x + context.camera.x;
          const worldMouseY = context.input.mouse.y + context.camera.y;
          const angle = Utils.getAngle(cx, cy, worldMouseX, worldMouseY);
          const speed = 12;

          const bullet = new Bullet(
            cx,
            cy,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed,
            true
          );
          context.bulletManager.add(bullet);

          context.camera.shake(2);
          context.particles.emitExplosion(
            cx + Math.cos(angle) * 15,
            cy + Math.sin(angle) * 15,
            "#fff"
          );
        }

        _checkWorldBounds() {
          if (this.y > Config.WORLD.HEIGHT + 100) {
            this.health = 0; // Fall death
          }
        }
      }

      // --- ENEMY ---
      class Enemy extends Actor {
        constructor(x, y) {
          super(x, y, 24, 24, Config.COLORS.ENEMY, 100);
          this.hasEyes = true;
          this.eyeColor = Config.COLORS.ENEMY_EYES;
          this.showHealthBar = true;
        }

        update(context) {
          this.updateAnimation();
          // Simple AI: Friction
          this.dx *= Config.PHYSICS.FRICTION || 0.8;
          context.physics.applyGravity(this);
          context.physics.resolveCollisions(this);
        }
      }

      // --- BULLET ---
      class Bullet extends Entity {
        constructor(x, y, dx, dy, isPlayer) {
          super(x, y, 0, 0, "#fff"); // Size handled by radius
          this.dx = dx;
          this.dy = dy;
          this.isPlayer = isPlayer;
          this.radius = 3;
        }
        // Bullets handle their own movement simply
        update(context) {
          this.x += this.dx;
          this.y += this.dy;
        }
      }

      // --- BULLET MANAGER ---
      class BulletManager {
        constructor() {
          this.bullets = [];
        }

        add(bullet) {
          this.bullets.push(bullet);
        }

        update(context) {
          for (let i = this.bullets.length - 1; i >= 0; i--) {
            const b = this.bullets[i];
            b.update(context);

            // Trail
            context.particles.emitTrail(
              b.x,
              b.y,
              b.isPlayer ? Config.COLORS.PLAYER : Config.COLORS.ENEMY,
              b.radius
            );

            // Bounds Check
            if (
              b.x < 0 ||
              b.x > Config.WORLD.WIDTH ||
              b.y < 0 ||
              b.y > Config.WORLD.HEIGHT
            ) {
              this.bullets.splice(i, 1);
              continue;
            }

            // Platform Collision
            let hitPlat = false;
            for (let plat of context.level.platforms) {
              if (
                Utils.checkAABB(
                  {
                    x: b.x - b.radius,
                    y: b.y - b.radius,
                    width: b.radius * 2,
                    height: b.radius * 2,
                  },
                  plat
                )
              ) {
                hitPlat = true;
                context.particles.emitExplosion(b.x, b.y, "#ccc");
                break;
              }
            }
            if (hitPlat) {
              this.bullets.splice(i, 1);
              continue;
            }

            // Entity Collision
            if (b.isPlayer) {
              const enemies = context.game.enemies;
              for (let j = enemies.length - 1; j >= 0; j--) {
                let e = enemies[j];
                if (
                  Utils.checkAABB(
                    { x: b.x, y: b.y, width: b.radius, height: b.radius },
                    e
                  )
                ) {
                  e.takeDamage(20);
                  context.particles.emitExplosion(b.x, b.y, Config.COLORS.ENEMY);
                  this.bullets.splice(i, 1);

                  if (e.health <= 0) {
                    context.particles.emitExplosion(
                      e.x + 12,
                      e.y + 12,
                      Config.COLORS.ENEMY
                    );
                    e.health = e.maxHealth; // Respawn logic
                  }
                  break;
                }
              }
            }
          }
        }

        draw(renderSystem) {
          this.bullets.forEach((b) => renderSystem.drawBullet(b));
        }
      }

      // ================== LEVEL DATA ==================
      class Level {
        constructor() {
          const w = Config.WORLD.WIDTH;
          const h = Config.WORLD.HEIGHT;

          this.platforms = [
            { x: -40, y: 0, width: 40, height: h }, // Left Wall
            { x: w, y: 0, width: 40, height: h }, // Right Wall
            { x: 0, y: -40, width: w, height: 40 }, // Ceiling
            { x: 0, y: h - 40, width: w, height: 80 }, // The Floor

            // Bottom Zone
            { x: 0, y: 1000, width: 250, height: 20 },
            { x: 250, y: 900, width: 20, height: 120 },
            { x: 400, y: 950, width: 150, height: 20 },
            { x: 700, y: 850, width: 150, height: 20 },
            { x: 1000, y: 950, width: 150, height: 20 },
            { x: 1700, y: 600, width: 20, height: 600 }, // Shaft
            { x: 1850, y: 800, width: 100, height: 20 },

            // Mid
            { x: 150, y: 750, width: 400, height: 20 },
            { x: 800, y: 650, width: 400, height: 20 },
            { x: 600, y: 500, width: 20, height: 250 },
            { x: 1200, y: 500, width: 20, height: 250 },

            // High
            { x: 200, y: 550, width: 150, height: 20 },
            { x: 50, y: 400, width: 200, height: 20 },
            { x: 650, y: 350, width: 200, height: 20 },
            { x: 1050, y: 350, width: 200, height: 20 },
            { x: 1500, y: 250, width: 400, height: 20 },
            { x: 1400, y: 150, width: 20, height: 120 },
          ];
        }
      }

      // ================== MAIN GAME CLASS ==================
      class Game {
        constructor() {
          this.canvas = document.getElementById("game");
          this.ctx = this.canvas.getContext("2d");

          // Initialize Systems
          this.input = new InputHandler(this.canvas);
          this.camera = new Camera();
          this.particles = new ParticleSystem();
          this.level = new Level();
          this.physics = new PhysicsSystem(this.level);
          this.renderer = new RenderSystem(this.ctx, this.camera);
          this.ui = new UIManager();
          this.bulletManager = new BulletManager();

          this.freezeFrames = 0;

          this.reset();
          this.loop = this.loop.bind(this);
          requestAnimationFrame(this.loop);
        }

        reset() {
          this.player = new Player();
          this.enemies = [new Enemy(450, 900)];
          this.bulletManager.bullets = [];
          this.ui.init(this.player.wallJumpsMax, this.player.maxDashes);
        }

        // Context object passed to entities so they can access systems
        // This acts as a Service Locator for the entities
        get context() {
          return {
            input: this.input,
            camera: this.camera,
            particles: this.particles,
            level: this.level,
            physics: this.physics,
            bulletManager: this.bulletManager,
            game: this,
          };
        }

        update() {
          // Camera
          this.camera.update(
            this.player,
            this.canvas.width,
            this.canvas.height
          );

          // Particles
          this.particles.update();

          // Player
          this.player.update(this.context);

          // Enemies
          this.enemies.forEach((e) => e.update(this.context));

          // Bullets
          this.bulletManager.update(this.context);

          // UI
          this.ui.update(this.player);

          // Input Cleanup
          this.input.clearFrame();
        }

        draw() {
          this.renderer.clear(this.canvas.width, this.canvas.height);
          this.renderer.begin();

          this.renderer.drawLevel(this.level);
          this.particles.draw(this.ctx);
          this.enemies.forEach((e) =>
            this.renderer.drawEntity(e, {
              x: this.player.x + this.player.width / 2,
              y: this.player.y + this.player.height / 2,
            })
          );
          this.renderer.drawEntity(this.player, {
            x: this.input.mouse.x + this.camera.x,
            y: this.input.mouse.y + this.camera.y,
          });
          this.bulletManager.draw(this.renderer);

          this.renderer.end();
          this.renderer.drawCursor(this.input.mouse);
        }

        loop() {
          if (this.freezeFrames > 0) {
            this.freezeFrames--;
            requestAnimationFrame(this.loop);
            return;
          }
          this.update();
          this.draw();
          requestAnimationFrame(this.loop);
        }
      }

      // Start Game
      const game = new Game();
    </script>
  </body>
</html>